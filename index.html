<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script> 
</head>
<body>
    <script>
    const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 800,
            parent: "game-container",
            pixelArt: true,
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: "arcade",
                arcade: {
                    gravity: { y: 0 } // Top down game, so no gravity
                }
            }
        };

        const game = new Phaser.Game(config);

        let controls;
        let player;

        function preload() {
            this.load.image("tiles", "./assets/tilesets/ProjectUtumno_full.png");
            this.load.tilemapTiledJSON("map", "./assets/tilemaps/test.json");
            this.load.atlas("atlas", "./assets/sprite/atlas.png", "./assets/sprite/atlas.json");
        }

        function create() {
            const map = this.make.tilemap({ key: "map" });

            // Parameters are the name you gave the tileset in Tiled and then the key of the tileset image in
            // Phaser's cache (i.e. the name you used in preload)
            const tileset = map.addTilesetImage("ProjectUtumno_full", "tiles");

            // Parameters: layer name (or index) from Tiled, tileset, x, y
            const aboveLayer = map.createStaticLayer("Bottom", tileset, 0, 0);
            const belowLayer = map.createStaticLayer("Top", tileset, 0, 0);

            belowLayer.setCollisionByProperty({ collides: true });

            const debugGraphics = this.add.graphics().setAlpha(0.75);

            belowLayer.renderDebug(debugGraphics, {
                tileColor: null, // Color of non-colliding tiles
                collidingTileColor: new Phaser.Display.Color(243, 134, 48, 255), // Color of colliding tiles
                faceColor: new Phaser.Display.Color(40, 39, 37, 255) // Color of colliding face edges
            });

            player = this.physics.add.sprite(400, 350, "atlas", "misa-front");
            player.body.collideWorldBounds = true;
            console.log(player);
            this.physics.add.collider(player, belowLayer, function() {
                console.log("i collided");
            });

            // Create the player's walking animations from the texture atlas. These are stored in the global
            // animation manager so any sprite can access them.
            const anims = this.anims;
            anims.create({
                key: "misa-left-walk",
                frames: anims.generateFrameNames("atlas", { prefix: "misa-left-walk.", start: 0, end: 3, zeroPad: 3 }),
                frameRate: 10,
                repeat: -1
            });
            anims.create({
                key: "misa-right-walk",
                frames: anims.generateFrameNames("atlas", { prefix: "misa-right-walk.", start: 0, end: 3, zeroPad: 3 }),
                frameRate: 10,
                repeat: -1
            });
            anims.create({
                key: "misa-front-walk",
                frames: anims.generateFrameNames("atlas", { prefix: "misa-front-walk.", start: 0, end: 3, zeroPad: 3 }),
                frameRate: 10,
                repeat: -1
            });
            anims.create({
                key: "misa-back-walk",
                frames: anims.generateFrameNames("atlas", { prefix: "misa-back-walk.", start: 0, end: 3, zeroPad: 3 }),
                frameRate: 10,
                repeat: -1
            });

            const camera = this.cameras.main;
            camera.startFollow(player);
            camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
            cursors = this.input.keyboard.createCursorKeys();
        }

        function update(time, delta) {
            // Stop any previous movement from the last frame
            player.body.setVelocity(0);

            // Horizontal movement
            if (cursors.left.isDown) {
                player.body.setVelocityX(-100);
            } else if (cursors.right.isDown) {
                player.body.setVelocityX(100);
            }

            // Vertical movement
            if (cursors.up.isDown) {
                player.body.setVelocityY(-100);
            } else if (cursors.down.isDown) {
                player.body.setVelocityY(100);
            }

            // Normalize and scale the velocity so that player can't move faster along a diagonal
            player.body.velocity.normalize().scale(175);

            // Update the animation last and give left/right animations precedence over up/down animations
            if (cursors.left.isDown) {
                player.anims.play("misa-left-walk", true);
            } else if (cursors.right.isDown) {
                player.anims.play("misa-right-walk", true);
            } else if (cursors.up.isDown) {
                player.anims.play("misa-back-walk", true);
            } else if (cursors.down.isDown) {
                player.anims.play("misa-front-walk", true);
            } else {
                player.anims.stop();
            }
        }
    </script>
</body>
</html>